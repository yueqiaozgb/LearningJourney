# 初识 InnoDB 存储引擎

## 什么是 InnoDB 存储引擎

InnoDB 是 MySQL 数据库中最重要且广泛使用的存储引擎，尤其适用于需要高可靠性、事务支持和并发控制的场景，支持完整的 **ACID 事务**、**行锁设计**、**支持MVCC**，**支持外键**等功能



## 为什么要学习 InnoDB 存储引擎

- **技术必要性**：它是 MySQL 数据库系统的核心组件，支撑高可靠、高并发的业务场景
- **职业竞争力**：深入理解 InnoDB 是开发者进阶的关键技能（过面试用的）
- **解决问题能力**：可针对性优化 SQL 性能、设计高效索引、排查死锁等生产问题



## 怎么学习和使用 InnoDB

- **阅读书籍**：MySQL技术内幕：InnoDB存储引擎
- **观看视频**：感觉视频还是更适合当学生的时候，什么都不懂，塞进脑子里的更多，现在更希望来份材料慢慢啃
- **知识总结**：用 AI 总结知识点，温故而知新
- **实际操作**：读万卷书不如行万里路，下载 MySQL 通过模拟高并发、死锁等场景加深理解



# InnoDB核心特性

InnoDB 之所以能成为 MySQL 最重要的存储引擎，在于其拥有的以下核心特征：

|     **特性**      |                           **说明**                           |
| :---------------: | :----------------------------------------------------------: |
| **ACID 事务支持** | 提供原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability），确保复杂操作的数据安全 |
|    **行级锁**     | 锁粒度细至数据行（而非表级锁），降低并发冲突，支持高吞吐量的读写操作 |
|     **MVCC**      | 多版本并发控制（Multi-Version Concurrency Control），通过版本快照实现非阻塞读 |
|   **外键约束**    |      强制维护表间引用完整性，自动处理级联更新/删除操作       |
|   **崩溃恢复**    | 通过 Redo Log（重做日志）和 Undo Log（回滚日志）实现快速故障恢复 |
|   **聚簇索引**    |  数据按主键顺序物理存储，主键查询极快，但二级索引需回表查询  |



## 事务

**事务（Transaction）** 是数据库操作的最小逻辑单元，由一组 SQL 语句组成，这些语句要么 **全部执行成功**，要么 **全部失败回滚**，不会出现部分执行的情况



### 事务的特性

|            特性            |                             说明                             |
| :------------------------: | :----------------------------------------------------------: |
|  **A（Atomicity）原子性**  |   事务是一个不可分割的整体，要么全部成功，要么全部失败回滚   |
| **C（Consistency）一致性** | 事务执行前后，数据库从一个合法状态变为另一个合法状态（如转账前后总金额不变） |
|  **I（Isolation）隔离性**  |      多个事务并发执行时，一个事务的操作不应影响其他事务      |
| **D（Durability）持久性**  | 事务一旦提交，对数据库的修改就是永久性的，即使系统崩溃也不会丢失 |



### 事务的基本操作

```sql
BEGIN;  -- 或 START TRANSACTION;

COMMIT;  -- 确认所有操作成功，持久化到数据库
-- 或
ROLLBACK; -- 撤销所有操作，回到事务开始前的状态
```



### 事务的隔离级别

多个事务同时执行时，可能出现以下问题：

|                 问题                  |                             描述                             |
| :-----------------------------------: | :----------------------------------------------------------: |
|        **脏读（Dirty Read）**         | 事务A读取了事务B **未提交** 的数据，事务B回滚后，事务A读到的是无效数据 |
| **不可重复读（Non-Repeatable Read）** | 事务A多次读取同一数据，事务B在期间修改并提交，导致事务A前后读取结果不一致 |
|       **幻读（Phantom Read）**        | 事务A查询某范围数据，事务B在期间插入新数据，事务A再次查询发现“凭空出现”的行 |



MySQL 支持 4 种隔离级别（默认 `REPEATABLE READ`）：

|       隔离级别       | 脏读 | 不可重复读 | 幻读 |             适用场景             |
| :------------------: | :--: | :--------: | :--: | :------------------------------: |
| **READ UNCOMMITTED** |  ❌   |     ❌      |  ❌   |             几乎不用             |
|  **READ COMMITTED**  |  ✅   |     ❌      |  ❌   | 允许不可重复读（如 Oracle 默认） |
| **REPEATABLE READ**  |  ✅   |     ✅      |  ❌   |         平衡一致性和性能         |
|   **SERIALIZABLE**   |  ✅   |     ✅      |  ✅   |       完全串行化，性能最低       |



### 设置隔离级别

```sql
-- 查看当前隔离级别
SELECT @@transaction_isolation;

-- 设置隔离级别（需重新连接生效）
SET GLOBAL TRANSACTION ISOLATION LEVEL REPEATABLE READ;
```



### 死锁问题

简单来说，就是事务A等待事务B释放资源，而事务B又在等待事务A释放资源，最终导致双方都无法完成

MySQL 会自动检测并回滚其中一个事务



# InnoDB 的存储结构

**表空间（Tablespace）**

- **系统表空间（ibdata1）**：存储元数据、Undo Log、Double Write Buffer（防止页断裂）。
- **独立表空间（.ibd 文件）**：每个表单独存储数据与索引（MySQL 5.6+ 默认启用），便于管理

**内存结构**

- **Buffer Pool**：缓存热数据页，减少磁盘 I/O。通过 LRU 算法管理淘汰策略
- **Change Buffer**：缓存非唯一索引的变更（Insert/Update/Delete），提升写性能
- **Log Buffer**：临时存储 Redo Log，定期刷盘。

**日志文件**

- **Redo Log**：记录物理操作，用于崩溃恢复（保证持久性）
- **Undo Log**：记录事务前的数据镜像，用于回滚和 MVCC